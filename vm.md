# 游戏掌机解释型8位汇编

## 虚拟硬件定义:
* 128个u8寄存器，支持加减乘除，0和最后16个寄存器为特殊变量，用于存放回调计算判断条件等
* 只支持条件绝对地址跳转，64大小的调用栈
* 128x64黑白屏幕，分成16x8块
* 64个8x8图块，按块绘制
* 按行绘制8x8文字，显示选择项(不超过128字节)
* 按块绘制1~3位数字(0~255)
* 5个按键，上下左右A
* 8位毫秒级计时器(建议使用循环加减法判断)
* 16个16字节存档槽，映射到最后16个寄存器
* 128(寄存器) + 128(调用栈) + 512(图块数据) + 128(字符串)

## 可变长指令
* 0x00 NOPE
* 0x01 EXIT
* 0x02 WKEY 等待按键发生变化，按键状态存于0
* 0x03 GKEY 获取当前按键状态，按键状态存于0
* 0x04 TICK 获取并重置8位毫秒计时器，存于0
* 0x05 SAVE 将最后16个寄存器数值写入flash存档
* 0x06 LOAD 将flash存档读入最后16个寄存器
* 0x07 TILE <1tid> <8data> 定义图块，VLSB格式
* 0x08 STOR <1num> <1reg> 将立即数写入reg
* 0x09 MOVE <1reg1> <1reg2> 将reg1写到reg2
* 0x0A ADDI <1reg> 将0与reg相加，存于0
* 0x0B SUBI <1reg> 将0减去reg，存于0
* 0x0C MULI <1reg> 0乘以reg，存于0
* 0x0D DIVI <1reg> 0除以reg，存于0
* 0x0E MODI <1reg> 0对reg取余，存于0
* 0x0F INVI 对0按位取反，存于0
* 0x10 JUMP <2addr> 跳转到addr处
* 0x11 JPEZ <2addr> 如果0等于0，跳转到addr处
* 0x12 JPGZ <2addr> 如果0大于0小于等于127，跳转到addr处
* 0x13 JPLZ <2addr> 如果0大于127，跳转到addr处
* 0x14 CALL <2addr> 跳转到addr处并保存返回地址
* 0x15 RETN 返回CALL之前的地址
* 0x16 DTIL <1reg1> <1reg2> 在reg1处绘制id为erg2的图块
* 0x17 DNUM <1reg1> <1reg2> 在reg1处绘制reg2
* 0x18 DTXT <1reg> <Nstr> 绘制文字
* 0x19 DSEL <1reg> <Nstr>...<1'\0'> 绘制一行选择项，并等待用户选择，存于0
* 0x1A RAND 用0作为种子生成一个随机数，存于0

## 特殊约定
* 如果reg >= 128，则表示访问(reg - 128)寄存器所指向的寄存器，即指针。
* 指针只允许指向寄存器，指向指针将出错。
* addr大端编码，即第一个字节为程序地址的高位
* 特殊寄存器名称:
  * r0(寄存器0), rs0~rs15(存档寄存器)
  * rc0~rc3(方法调用参数/返回值寄存器)
* GKEY和WKEY获取到的是按键事件，0表示无事件发生，高位2bit表示按键事件，低位6bit指示按键。

## 基础语法
* r??? 命名寄存器，编译时自动分配
* \*r??? 将r???当作指针访问(即r???编号+128)
* &r??? 获得r???分配的寄存器编号，只能当作立即数使用
* :l??? 标记标签
* l??? 标签，只能用于跳转指令
* 数字开头 立即数，0x为16进制，0b为二进制，其它为10进制
* ;注释
* @拓展宏(暂未实现)

## 拓展语法
* a??? 连续的寄存器(数组)，a???{n}定义长度，a???[n]访问指定下标的元素
* @CALC (\*)r??? = (\*)r??? +|-|\*|/|% (\*)r???
* @CALC (\*)r??? = ~ (\*)r???
